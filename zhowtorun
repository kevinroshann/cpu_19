iverilog -o output.vvp my_design.v my_testbench.v

vvp output.vvp

gtkwave dump.vcd




`timescale 1ns/1ps

module cpu_call_ret_tb;

    // Testbench signals
    reg clk;
    reg reset;
    
    // Internal signals for monitoring
    wire [18:0] instruction;
    wire [3:0] opcode, rs1, rs2, rd;
    wire [2:0] alu_type, alu_op;
    wire [1:0] funct2, type;
    wire [10:0] jump_addr, call_addr;
    wire [7:0] branch_addr, mem_addr;
    wire [18:0] readdata1, readdata2, result, alu_b, mem_data, write_data;
    wire regwrite, alu_use, branch_en, jump_en, mem_read, mem_write, call_en, ret_en, pc_src, zero;
    wire [18:0] pc_out, pc_next;
    wire [3:0] sp_out;
    wire [18:0] stack_top;
    wire stack_empty, stack_full;
    
    // Variables for testbench
    integer cycle_count;
    integer i;
    integer max_cycles;
    
    // Instantiate the CPU
    cpu cpu_dut (
        .clk(clk),
        .reset(reset),
        // Expose internal signals for monitoring
        .instruction_out(instruction),
        .opcode_out(opcode),
        .rs1_out(rs1),
        .rs2_out(rs2),
        .rd_out(rd),
        .alu_type_out(alu_type),
        .alu_op_out(alu_op),
        .funct2_out(funct2),
        .type_out(type),
        .jump_addr_out(jump_addr),
        .branch_addr_out(branch_addr),
        .mem_addr_out(mem_addr),
        .call_addr_out(call_addr),
        .readdata1_out(readdata1),
        .readdata2_out(readdata2),
        .result_out(result),
        .alu_b_out(alu_b),
        .mem_data_out(mem_data),
        .write_data_out(write_data),
        .regwrite_out(regwrite),
        .alu_use_out(alu_use),
        .branch_en_out(branch_en),
        .jump_en_out(jump_en),
        .mem_read_out(mem_read),
        .mem_write_out(mem_write),
        .call_en_out(call_en),
        .ret_en_out(ret_en),
        .pc_src_out(pc_src),
        .zero_out(zero),
        .pc_out(pc_out),
        .pc_next_out(pc_next),
        .sp_out(sp_out),
        .stack_top_out(stack_top),
        .stack_empty_out(stack_empty),
        .stack_full_out(stack_full)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 10ns period = 100MHz
    end
    
    // Helper function to decode instruction type
    function [31:0] get_instr_name;
        input [1:0] type_in;
        input [3:0] opcode_in;
        input [2:0] alu_type_in;
        input [1:0] funct2_in;
        input [7:0] branch_addr_in;
        begin
            case (opcode_in)
                4'b0001: begin // R-type
                    case (alu_type_in)
                        3'b000: get_instr_name = "ADD";
                        3'b001: get_instr_name = "SUB";
                        3'b010: get_instr_name = "MUL";
                        3'b011: get_instr_name = "DIV";
                        3'b100: get_instr_name = "AND";
                        3'b101: get_instr_name = "OR ";
                        3'b110: get_instr_name = "XOR";
                        3'b111: get_instr_name = "NOT";
                        default: get_instr_name = "R??";
                    endcase
                end
                4'b0010: begin // I-type
                    case (funct2_in)
                        2'b00: get_instr_name = "INC";
                        2'b01: get_instr_name = "DEC";
                        2'b10: get_instr_name = "NOT";
                        default: get_instr_name = "I??";
                    endcase
                end
                4'b0011: get_instr_name = "JMP"; // J-type
                4'b0100: begin // B-type
                    if (branch_addr_in[0] == 1'b0)
                        get_instr_name = "BEQ";
                    else
                        get_instr_name = "BNE";
                end
                4'b0101: get_instr_name = "LD "; // Load
                4'b0110: get_instr_name = "ST "; // Store
                4'b0111: get_instr_name = "CALL"; // Call
                4'b1000: get_instr_name = "RET"; // Return
                default: get_instr_name = "???";
            endcase
        end
    endfunction
    
    // Test stimulus
    initial begin
        // Initialize
        $dumpfile("cpu_call_ret_test.vcd");
        $dumpvars(0, cpu_call_ret_tb);
        
        $display("Starting CPU Test with CALL/RET Subroutine Instructions...");
        $display("Time\tCyc\tPC\tInstr\t\t\t\tName\tSP\tStk_Top\tCall_A\tR1\tR2\tR3\tR4\tR5\tR6\tR7\tC\tR\tPC_src");
        $display("----\t---\t--\t-----\t\t\t\t----\t--\t-------\t------\t--\t--\t--\t--\t--\t--\t--\t-\t-\t------");
        
        // Reset the processor
        reset = 1;
        #12; // Hold reset longer
        reset = 0;
        
        // Wait for reset to complete and let first instruction stabilize
        #3;
        
        // Monitor instructions - stop when PC goes beyond program or after reasonable cycles
        cycle_count = 0;
        max_cycles = 200; // Limit to prevent infinite loops during debugging
        
        while (pc_out <= 19'd31 && $time < 3000 && cycle_count < max_cycles) begin
            cycle_count = cycle_count + 1;
            
            // Display current state before clock edge
            $display("%0t\t%0d\t%0d\t%b\t%s\t%0d\t%0d\t%0d\t%0d\t%0d\t%0d\t%0d\t%0d\t%0d\t%0d\t%b\t%b\t%b", 
                     $time, cycle_count, pc_out, instruction, 
                     get_instr_name(type, opcode, alu_type, funct2, branch_addr),
                     sp_out, stack_top, call_addr,
                     cpu_dut.register_file1.mem[1], cpu_dut.register_file1.mem[2], cpu_dut.register_file1.mem[3],
                     cpu_dut.register_file1.mem[4], cpu_dut.register_file1.mem[5], cpu_dut.register_file1.mem[6], 
                     cpu_dut.register_file1.mem[7], call_en, ret_en, pc_src);
            
            // Special debug for DEC instruction
            if (pc_out == 19'd28) begin
                $display("    -> DEC DEBUG: r7 before = %0d, ALU result = %0d", readdata1, result);
            end
            
            // Detailed analysis of each instruction type
            case (opcode)
                4'b0101: begin // Load operations
                    $display("    -> LD: Loading from addr %0d into r%0d, data = %0d", mem_addr, rd, mem_data);
                end
                
                4'b0110: begin // Store operations
                    $display("    -> ST: Storing r%0d (value %0d) to addr %0d", rs1, readdata1, mem_addr);
                end
                
                4'b0001: begin // R-type ALU operations
                    if (alu_type == 3'b000) begin // ADD
                        $display("    -> ADD: r%0d(%0d) + r%0d(%0d) = %0d -> r%0d", rs1, readdata1, rs2, readdata2, result, rd);
                    end else if (alu_type == 3'b001) begin // SUB  
                        $display("    -> SUB: r%0d(%0d) - r%0d(%0d) = %0d -> r%0d", rs1, readdata1, rs2, readdata2, result, rd);
                    end
                end
                
                4'b0010: begin // I-type immediate operations
                    if (funct2 == 2'b01) begin // DEC
                        $display("    -> DEC: r%0d(%0d) - 1 = %0d", rs1, readdata1, result);
                    end
                end
                
                4'b0111: begin // CALL instruction
                    if (!stack_full) begin
                        $display("    -> CALL: Calling subroutine at addr %0d", call_addr);
                        $display("    ->       Pushing return address %0d to stack, SP: %0d -> %0d", pc_out + 1, sp_out, sp_out - 1);
                    end else begin
                        $display("    -> CALL: Stack full, call ignored");
                    end
                end
                
                4'b1000: begin // RET instruction
                    if (!stack_empty) begin
                        $display("    -> RET: Returning to address %0d", stack_top);
                        $display("    ->      Popping from stack, SP: %0d -> %0d", sp_out, sp_out + 1);
                    end else begin
                        $display("    -> RET: Stack empty, return ignored");
                    end
                end
                
                4'b0100: begin // Branch operations
                    if (branch_addr[0] == 1'b0) begin // BEQ
                        $display("    -> BEQ: Compare r%0d(%0d) == r%0d(%0d)", rs1, readdata1, rs2, readdata2);
                    end else begin // BNE
                        $display("    -> BNE: Compare r%0d(%0d) != r%0d(%0d)", rs1, readdata1, rs2, readdata2);
                    end
                    if (pc_src) begin
                        $display("    ->      Branch taken to addr %0d", branch_addr[7:1]);
                    end else begin
                        $display("    ->      Branch not taken");
                    end
                end
                
                4'b0011: begin // Jump operations
                    $display("    -> JMP: Jumping to address %0d", jump_addr);
                end
            endcase
            
            // Wait for next clock edge
            @(posedge clk);
            #1; // Small delay to allow signals to settle
        end
        
        if (cycle_count >= max_cycles) begin
            $display("\nSimulation stopped after %0d cycles to prevent infinite loop", max_cycles);
        end
        
        $display("\n=== CALL/RET Test Summary ===");
        $display("Final Register States:");
        $display("r1 = %0d (should be 5)", cpu_dut.register_file1.mem[1]);
        $display("r2 = %0d (should be 7)", cpu_dut.register_file1.mem[2]);
        $display("r3 = %0d (should be 12)", cpu_dut.register_file1.mem[3]);
        $display("r4 = %0d (should be 12)", cpu_dut.register_file1.mem[4]);
        $display("r5 = %0d (should be 24)", cpu_dut.register_file1.mem[5]);
        $display("r6 = %0d (should be 24)", cpu_dut.register_file1.mem[6]);
        $display("r7 = %0d (should be 0)", cpu_dut.register_file1.mem[7]);
        
        $display("\nStack Status:");
        $display("Stack Pointer = %0d (should be 15 - empty)", sp_out);
        $display("Stack Empty = %b (should be 1)", stack_empty);
        $display("Stack Full = %b (should be 0)", stack_full);
        
        // Debug: Show the actual instruction encoding for DEC
        $display("\nDEBUG - DEC Instruction Analysis:");
        $display("instr_mem[28] = %b", cpu_dut.instr_mem1.instr_mem[28]);
        $display("Expected:       0010011101000111000 (DEC r7)");
        
        if (cpu_dut.register_file1.mem[3] == 19'd12 && 
            cpu_dut.register_file1.mem[5] == 19'd24 && 
            cpu_dut.register_file1.mem[7] == 19'd0 &&
            sp_out >= 4'd15) begin
            $display("\nCALL/RET Test PASSED! All subroutines executed correctly.");
        end else begin
            $display("\nCALL/RET Test FAILED! Check subroutine execution.");
            $display("Debug info:");
            $display("  r3 = %0d (expected 12)", cpu_dut.register_file1.mem[3]);
            $display("  r5 = %0d (expected 24)", cpu_dut.register_file1.mem[5]);
            $display("  r7 = %0d (expected 0)", cpu_dut.register_file1.mem[7]);
            $display("  SP = %0d (expected 15)", sp_out);
        end
        
        $display("\nSimulation completed!");
        $finish;
    end
    
    // Timeout protection
    initial begin
        #5000;
        $display("Simulation timeout!");
        $finish;
    end

endmodule